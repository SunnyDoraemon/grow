# Go语言的类型系统

> Go是一种静态类型的编程语言；这意味着编译器需要在编译时知晓程序里每个值的类型；如果提前知道类型信息，编译器就可以确保程序合理的使用值，有助于减少潜在的内存异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。

## 5.1 用户定义的类型
> Go允许用户自定义类型；当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息。<br>

Go中声明自定义类型有两种方法，最常用的是使用关键字`struct`，可以让用户创建一个结构类型。<br>
结构类型通过组合一系列固定切唯一的字段来声明；结构中的每个字端都会用一个已知的类型来声明；这个已知类型可以是内置类型，也可以是其他自定义类型。<br>
```golang
type user struct {
    name        string
    age         int
    email       string
    privileged  bool
}
```
可以看到结构类型的声明，由关键字`type`开始，后面是类型的名称，最后是关键字`struct`,然后描述了4个字段，每个字段都基于一个内置类型。

定义了类型之后就可以使用它。
```golang
var leo user
// 关键字var 创建了类型为user的leo变量

// 当声明变量时，这个变量对应的值总会被初始化，这个值要么用指定的值初始化，要么用零值（变量类型的默认值）做初始化。

// 数值类型的零值是0，字符串类型的零值是空字符串，bool类型的零值是false

// 任何时候创建一个零值变量，习惯是使用关键字var

// 使用结构字面量来声明一个变量
lisa := user{
    name:       "Lisa",
    age:        25,
    email:      "lisa@email.com",
    privileged: true,
}

// 字段匿名方式，要保证和结构体声明的字段顺序一致
joy := user{"Joy", 26, "joy@email.com", true}

// 当声明结构类型时，字段的类型并不限制在内置类型，也可以使用其他自定义类型

type admin struct {
    person user
    level  string
}
fred := admin{
    person: user{
        name:       "Joy",
        age:        26,
        email:      "joy@email.com",
        privileged: true,
    },
    level: "superAdmin",
}
```
除了上述的使用`struct`来定义类型之外，还有一种方法是，基于已有的类型，将其作为新类型的类型说明<br>
当需要一个可以用已有类型表示的新类型的时候，这种方法会很好用<br>
标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的类型，并赋予更高级的功能。
```golang
type Duration int64
```
上述代码中描述的是`time`包中的一个类型声明`Duration`，这个类型使用内置的`int64`类型作为其表示<br>

在`Duration`的类型声明中，我们将`int64`类型叫作`Duration`的基础类型<br>

值得注意的是，虽然`int64`是`Duration`的基础类型，但是Go并不认为`Duration`和`int64`是同一种类型，这两个类型是完全不同的有区别的类型。
```golang
package main

type Duration int64

func main() {
    var dur Duration
    dur = int64(1000)
    // 编译报错
    // cannot use int64(1000) (constant 1000 of type int64) as Duration value in assignment
}
```
上述代码中，编译器很清楚，`int64`的值不能作为类型`Duration`的值来使用；虽然`int64`是`Duration`的基础类型，但`Duration`依然是一个独立的类型；两种不同类型的值即使是相互兼容的，但也不能相互赋值，编译器是不会对不同类型的值做隐式转换。

## 5.2 方法
> 方法能给用户定义的类型添加新的行为；方法实际上也是函数，只是在声明时，在关键字`func`和方法名之间增加了一个参数。
```golang
package main

import "fmt"

type user struct {
	name  string
	email string
}

// 使用值接收者
// 使用值接收者声明的方法，调用时会使用这个值的一个副本来执行
func (u user) notify() {
	fmt.Printf("Sending User Email to %s<%s>\n", u.name, u.email)
}

// 使用指针接收者
// 当调用使用指针接收者声明的方法时，这个方法会共享调用指针接收者指向的值
func (u *user) changeEmail(email string) {
	u.email = email
}

func main() {
	// 声明一个user类型的变量bill,并初始化了其值
	bill := user{"Bill", "bill@email.com"}
	// 这个语法和调用一个包里的函数看起来很类似；但这里bill不是包名，而是变量名
	// 这里在调用notify方法时，使用bill的值作为接收者进行调用，方法notify会接收到bill值的一个副本
	bill.notify()

	// 指向user类型值的指针，也可以用来调用使用值接收者声明的方法
	lisa := &user{"Lisa", "lisa@email.com"}
	// 实际上Go编译器为了支持这种调用，背后完成了 (*lisa).notify()的操作，指针被解引用为值
	lisa.notify()

	// user类型的值可以用来调用使用指针接收者声明的方法
	// Go编译器为了支持这种调用，背后完成了 (&bill).changeEmail("bill@163.com") 的操作
	// 首先引用bill值得到一个指针，也就是(&bill),这样这个指针就能匹配方法的接收者类型，再进行调用
	// Go语言在支持上，既允许值，也允许指针来调用方法
	bill.changeEmail("bill@163.com")
	bill.notify()

	// 指向user类型值的指针，也可以用来调用使用指针接收者声明的方法
	// 使用指针接收者声明的方法，在方法内部对指针接收者值作出的改变也会反映在调用者指针指向的值上
	// 值接收者使用值的副本来调用方法，指针接收者使用指针所指向的实际值来调用方法
	lisa.changeEmail("lisa@163.com")
	lisa.notify()

	// Output:
	// Sending User Email to Bill<bill@email.com>
	// Sending User Email to Lisa<lisa@email.com>
	// Sending User Email to Bill<bill@163.com>
	// Sending User Email to Lisa<lisa@163.com>
}

```

关键字`func`和函数名之间的，被称为`接收者`，将函数与接收者的类型绑定在一起。如果一个函数有`接收者`，那么这个函数就被称为`方法`。
Go语言中有两种类型的接收者:
- 值接收者
    ```golang
    // 使用值接收者声明的方法，在调用时会使用这个值的副本来执行。
    func (u user) notify()
    ```
- 指针接收者
    ```golang
    func (u *user) changeEmail(email string)
    ```
## 5.3 类型的本质
> 在声明一个新类型之后，声明一个该类型的方法之前，需要考虑一个问题：这个类型的本质是什么？<br>
> TODO

### 5.3.1 内置类型
内置类型是由Golang原生提供的一些类型;比如：数值类型、字符串类型、布尔类型<br><br>
这些类型本质上是原始的类型，当对这些值进行增加或者删除的时候，会创建一个新值；当把这些类型的值传递给方法或者函数是，传递的是一个对应值的副本。<br>

标准库里的strings包里的Trim函数，传入一个string类型的值用于操作，再传入一个string类型的值用于查找，最后返回一个新的string值；这个函数对调用者的原始string值(实参)副本做操作。并返回一个新string的副本。<br>

字符串(string)和整数、浮点数以及布尔值一样，本质上是一种很原始的数值，所以在函数或方法内外传递时，传递的是其副本。
```golang
func Trim(s stirng, cutset string) string {
    if s == "" || cutset == "" {
        return s
    }
    return TrimFunc(s, makeCutsetFunc(cutset))
}
```

### 5.3.2 引用类型
> Go语言里，`切片`、`映射`、 `通道`、`接口`和`函数`类型，都是引用类型。

当声明引用类型的变量时，创建的变量被称为`标头(header)值`<br><br>
每个引用类型创建的`标头值`是包含一个指向底层数据结构`的指针`<br><br>
每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制儿设计的，所以永远不需要共享一个引用类型的值(不需要传递其指针),因为`标头值`本身就有一个指向底层数据结构的指针，所以通过值传递的特性去复制一个引用类型的值的副本，本质上其实就是在共享底层数据结构。<br><br>
比如下面的slice和map的部分源码就可以看到,`slice`的`array`字段就是指向底层数组结构的指针；`map(本质上使用的hmap结构)`的`buckets`是指向底层数据结构的指针
```golang
// https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/slice.go#L15
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}

// https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/map.go#L117

// A header for a Go map.
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}
```
来看个net标准库的实际例子
```golang
// https://github.com/golang/go/blob/release-branch.go1.21/src/net/ip.go#L330
...

type IP []byte

...

func (ip IP) MarshalText() ([]byte error) {
    if len(ip) == 0 {
        return []byte(""), nil
    }
    if len(ip) != IPv4len && len(ip) != IPv6len {
        return nil, errors.New("invalid IP address")
    }
    return []byte(ip.String()), nil
}

...

func ipEmptyString(ip IP) string {
	if len(ip) == 0 {
		return ""
	}
	return ip.String()
}
```
可以看到名为`IP`的类型被声明为字节切片<br><br>
当要围绕相关的内置类型或者引用类型来声明自定义行为的时候，直接基于已有类型来声明自定义的类型会很好用。<br><br>
MarshalText方法是用IP类型的值接收者声明的。值接收者使用复制原值来传递。<br><br>

ipEmptyString函数传入IP类型的值；调用者传入的是这个引用类型的值，而不是通过引用共享给这个函数。调用者将这个引用类型的值的副本传入这个函数；引用类型的值在其他方面像原始的数据类型一样，也是通过值传递。

### 5.3.3 结构类型
> 结构类型可以用来描述一组数据值；这些值可以是原始的内置类型，也可以是非原始的类型。<br>

```golang
type Time struct {
	// sec 是自公元1年1月1日00:00:00开始的秒数
	sec		int64
	// nsec 制定了一秒内的纳秒偏移
	// 非零值
	// 必须在(0, 999999999]范围内
	nsec	int64
	// loc指定了一个Location
	// 用于决定改时间对应的当地的分、小时、天和年的值
	// 只有Time的零值,其loc的值才是nil,这种情况下,认为处于UTC时区
	loc		*Location
}
``` 
上述`Time`结构来自time包。当考虑时间的值时,应该意识到给定一个时间点的时间应该是不允许修改的。所以标准库里也是这样实现Time类型的。

**TODO**
> 内嵌类型的作用暂时不明白，后续应该重读章节5.3.3

## 5.4 接口

> 多态是指代码可以根据类型的具体实现而采取不同行为的能力。<br>
> 如果一个类型实现了某个接口，那么所有使用这个接口的地方，都可以支持这种类型的值。<br>
> 标准库里就有类似的例子，如io包里实现的流式处理接口。io包提供了一组构造得非常好的接口喝函数，来让代码轻松支持流式数据处理。只要实现两个接口，就能利用整个io包背后的所有强大能力。<br>

我们的程序在声明喝实现接口时会设计很多细节；即便实现的事已有接口，也需要了解这些接口时如何工作的。在探究接口如何工作以及实现的细节之前，我们先来看一下使用标准库里的接口的例子。

### 5.4.1 标准库
> 我们来看一个示例程序，这个程序实现`curl`的功能

```golang
// 这个示例程序展示如何使用io.Reader和io.Writer接口
// 写一个简单版本的curl程序
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
)

// init 在main之前调用
func init() {
	if len(os.Args) != 2 {
		fmt.Println("Usage:./example2 <url>")
		os.Exit(-1)
	}
}

func main() {
	r, err := http.Get(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}
	io.Copy(os.Stdout, r.Body)
	if err := r.Body.Close(); err != nil {
		fmt.Println(err)
	}
}
```

上述代码展示了接口的能力以及在标准库里面的应用。只用了几行代码就通过两个函数以及配套的借口，完成了curl程序。在第23行，调用http包的Get函数，在与服务器的成功通信后，http.Get函数会返回一个http.Response类型的指针。http.Response类型包含一个名为body的字段，这个字段是一个io.ReadCloser类型的值。<br>

在第30行,Body字段作为第二个参数传递给io.Copy函数。io.Copy函数的第二个参数接受一个io.Reader接口类型的值，这个值表示数据流入的源。Body字段实现了io.Reader接口，因此可以讲Body传入io.Copy。<br>

io.Copy的第一个参数是复制到的目标，这个参数必须是一个实现了io.Writer接口的值，对于这个目标，传入了os包里面的一个特殊值`Stdout`。这个接口值表示标准输出设备，并且已经实现了io.Writer接口。当我们将Body和Stdout这两个值传递给io.Copy函数后，这个函数会把服务器的数据分成小段，源源不断地传递给终端窗口，直到最后一个片段读取并写入终端后，io.Copy函数才return。<br>

io.Copy函数可以以这种工作流的方式处理很多标准库里面的已有类型。
```golang
// bytes.Buffer也可以用于io.Copy函数
package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

func init() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: ./example2 <url>")
		os.Exit(-1)
	}
}

```

